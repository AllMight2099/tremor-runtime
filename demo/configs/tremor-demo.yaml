# Demo file that will read events from kafka, classify them into two categories
# and print statistics on the console  
---

onramps:                                          # First we define our datasources or onramps
  - onramp::kafka:                                # In this example we only have a single kafka onramp
      group_id: demo                              # The kafka consumer group is `demo`
      topics:                                     # We consume form a single topic `demo`, but it would
        - demo                                    # be possible to add additional topics below this line 
      brokers:                                    # We define our broker `kafka:9092`, but again it would
        - kafka:9092                              # be possible to add additional topics below this line
      pipeline: main                              # Finally we define the pipeline this onramp sends to as `main`

pipelines:                                        # Second we define the pipelines this instance will start
  - name: main                                    # We only define one pipeline named `main`
    steps:                                        # The pipeline is going to have the following steps
      - parse::json                               # Parse the event as a JSON to work on it's content
      - runtime::mimir:                           # We run a mimir script with two rules on it
          script: |
            export classification;
            # The first class we define is named `info`,
            # it matches if `short_message`  contains the string `"info"`
            short_message:"info" { $classification := "info"; tremor.class := "info"; return; }
            # The second class we define is `error`, it matches
            # if  `short_message` contains the string `"ERROR`
            short_message:"ERROR" { $classification := "error"; tremor.class := "error";  return; }
            _ { $classification := "default"; }
      - grouper::bucket:                          # Now we limit how much each class is allowed to send per second
           buckets:
             info:                                # the class `info` is allowed to send 10 events / s
               rate: 10
             error:                               # the class `error` is allowed to send 100 events / s
               rate: 100
             default:                             # the `default` class contains all elements that didn't 
               rate: 90                           # match any of the rules, it is allowed to send 90 events / s
      - render::json                              # Once the bucketing is applied we render the json back to a blob
      - offramp::debug                            # Finally we use the `debug` output to print the data to the console
