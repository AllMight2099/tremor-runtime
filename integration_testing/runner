#!/usr/bin/env sh

BASEDIR=$(dirname "$0")

. ${BASEDIR}/common.sh

help() {
    cat <<EOF
Usage: ${0##*/} [-hd] [-t TARGET] [-c CMD] [TEST]...
tremor-runtime test runner
  -h         show this help
  -l         lists all tests
  -n NAME    creates a new test from the template
  -d         set -x for tracing
  -t TARGET  selects the build target 'debug', 'release', or 'none'
  -c CMD     command to run for tests, defaults to the command appropriate to the
             build target. Required for 'none'.
EOF
}
while getopts hdlt:c:n: opt; do
    case $opt in
        h)
            help
            exit 0
            ;;
        d)
            set -x
            ;;
        t)
            build_target=$OPTARG
            ;;
        l)
            ls -d ${BASEDIR}/*.test | sed -e 's/\.test$//g' -e "s;^${BASEDIR}/;;g"
            exit 0
            ;;
        n)
            test=$OPTARG
            if [ -d ${BASEDIR}/${test}.test ]
            then
                echo "Test ${test} already exists"
                exit 1
            fi
            cp -r ${BASEDIR}/template.test ${BASEDIR}/${test}.test
            exit 0
            ;;
        c)
            run_cmd=$OPTARG
            ;;
        *)
            help
            exit 1
            ;;
    esac
done

if [ -z ${build_target+x} ]
then
    build_target=debug
fi

case $build_target in
    debug)
        cargo build
        ;;
    release)
        cargo build --release
        ;;
    none)
        ;;
    *)
        echo "Unknown build target `$BUILD_TARGET`"
        exit 1
        ;;
esac

shift "$((OPTIND-1))"

case $build_target in
    debug)
        run_cmd=${run_cmd:-"${BASEDIR}/../target/debug/tremor-runtime"}
        ;;
    release)
        run_cmd=${run_cmd:-"${BASEDIR}/../target/release/tremor-runtime"}
        ;;
    none)
        if [ -z ${run_cmd+x} ]
        then
            echo "the run command (-c) needs to be set with the 'none' target."
            exit 1
        fi
esac

echo $run_cmd


if [ ! -z ${@+x} ]
then
    tests=$@
fi

if [ -z "${tests}" ]
then
    tests=$(ls -d ${BASEDIR}/*.test | sed -e 's/\.test$//g' -e "s;^${BASEDIR}/;;g")
fi

for test in $tests
do
    config_file="${BASEDIR}/${test}.test/config"
    data_file="${BASEDIR}/${test}.test/in.json"

    gen_file="${BASEDIR}/${test}.test/gen.json"
    exp_file="${BASEDIR}/${test}.test/exp.json"
    log_file="${BASEDIR}/${test}.test/log.txt"

    TEST_DIR="${BASEDIR}/${test}.test"
    if [ ! -d "${TEST_DIR}" ]
    then
        error "${test}: directory '${TEST_DIR}' not found"
        exit 1
    fi

    in_file="${BASEDIR}/${test}.test/in.json.xz"
    if [ ! -f "${in_file}" ]
    then
        error "${test}: file '${in_file}' not found"
        exit 1
    fi

    rules_file="${BASEDIR}/${test}.test/rules.json"
    if [ ! -f "${rules_file}" ]
    then
        error "${test}: file '${rules_file}' not found"
        exit 1
    else
        rules=`cat ${rules_file}`
    fi

    out_file="${BASEDIR}/${test}.test/out.json.xz"
    if [ ! -f "${out_file}" ]
    then
        error "${test}: file '${out_file}' not found"
        exit 1
    fi

    readme_file="${BASEDIR}/${test}.test/README.md"
    if [ ! -f "${readme_file}" ]
    then
        error "${test}: file '${readme_file}' not found"
        exit 1
    fi

    # reset config
    should_crash=0
    onramp="file"
    onramp_config="${data_file}"
    offramp="file"
    offramp_config="${gen_file}"
    drop_offramp="null"
    drop_offramp_config=""
    parser="json"
    parser_config=""
    classifier="mimir"
    classifier_config=${rules:-""}
    grouping="bucket"
    grouping_config=${rules:-""}
    limiting="pass"
    limiting_config=""
    threads=1

    if [ -f "${config_file}" ]
    then
        . ${config_file}
    else
        echo "Missing config file: ${config_file}"
        exit 1
    fi

    # Limiting Configuration


    xzcat $in_file > $data_file
    cat ${readme_file}
    if $run_cmd --on-ramp "${onramp}" --on-ramp-config "${onramp_config}" \
                --off-ramp "${offramp}" --off-ramp-config "${offramp_config}" \
                --drop-off-ramp "${drop_offramp}" --drop-off-ramp-config "${drop_offramp_config}" \
                --parser "${parser}" --parser-config "${parser_config}" \
                --classifier "${classifier}" --classifier-config "${classifier_config}" \
                --grouping "${grouping}" --grouping-config "${grouping_config}" \
                --limiting "${limiting}" --limiting-config "${limiting_config}" \
                --pipeline-threads "${threads}" 2> ${log_file}
    then
        if [ "${should_crash}" -eq 0 ] # if we do not wanted this test to crash
        then
            xzcat ${out_file} > ${exp_file}
            rm ${data_file}
            if diff ${gen_file} ${exp_file} > /dev/null
            then
                rm ${gen_file} ${exp_file} ${log_file}
                ok "${test}: passed"
                PASSED_TESTS="${PASSED_TESTS}$test "
            else
                error "${test}: failed"
                FAILED_TESTS="${FAILED_TESTS}$test "
            fi
        else
            error "${test}: execution failure expected but success received"
            FAILED_TESTS="${FAILED_TESTS}$test "
        fi
    else
        exit_code=$?
        rm ${data_file}
        if [ ${exit_code} -eq 139 ]
        then
            error "${test}: SEGFAULT"
            FAILED_TESTS="${FAILED_TESTS}$test "
        else
            if [ "${should_crash}" -eq 0 ]
            then
                error "${test}: execution failed"
                FAILED_TESTS="${FAILED_TESTS}$test "
            else
                ok "${test}: expected failure"
                PASSED_TESTS="${PASSED_TESTS}$test "
            fi
        fi

    fi
done

if [ ! -z "${PASSED_TESTS+x}" ]
then
    echo "Passed test cases: ${PASSED_TESTS}"
fi

if [ ! -z "${FAILED_TESTS+x}" ]
then
    echo "Failed test cases: ${FAILED_TESTS}"
    exit 1
fi

if [ -z "${PASSED_TESTS+x}" ]
then
    echo "No tests run, this is bad"
    exit 1
fi
