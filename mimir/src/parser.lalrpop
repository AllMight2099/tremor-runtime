// Copyright 2018-2019, Wayfair GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use regex;
use std::str::FromStr;
use serde_json::{json, Value};
use crate::{Item, Stmt, Cmp, Filter, CIDR, Action, Script, RHSValue, Path, Interface, Id};
use pcre2::bytes::{RegexBuilder, Regex};
use glob::Pattern;

grammar;

pub Script: Script = {
    <interface:Interface> <statements:Stmts> => Script{interface, statements},
    <Stmts> => Script{interface: Interface::default(), statements: <>},
}

Import: Vec<Id> = {
    IMPORT <VarList> ";" => <>,
}

Export: Vec<Id> = {
    EXPORT <VarList> ";" => <>
}

Interface: Interface = {
    <imports:Import> <exports:Export> => Interface{imports, exports},
    <exports:Export> <imports:Import> => Interface{imports, exports},
    <imports:Import> => Interface{imports, exports: Vec::new()},
    <exports:Export> => Interface{imports: Vec::new(), exports},
}

VarList: Vec<Id> = {
    <list:VarList> COMMA <item:Id> => {
        let mut list = list;
        list.push(item);
        list
    },
    Id => vec![<>]
}

Stmts: Vec<Stmt> = {
    <stmts: Stmts> <stmt: Stmt> => {
        let mut stmts: Vec<Stmt> = stmts;
        stmts.push(stmt);
        stmts
    },
    <Stmt> => vec![<>],
    <Stmts> SLC => <>,
    SLC => vec![],

}

Stmt: Stmt = {
    Item => Stmt{item: <>, actions: Vec::new()},
    <item:Item> CBOpen <actions: Actions> ";" CBClose => Stmt{item, actions},
}



// Filter related

// An item can be a filter expression, a parenthesized expression, or a
// predicate expression.
Item: Item = {
    MaybeNegatedFilter => <>,
    Enclosed => <>,
    <l: Item> AND <r: MaybeNegatedFilter> => Item::And(Box::new(l), Box::new(r)),
    <l: Item> OR <r: MaybeNegatedFilter> => Item::Or(Box::new(l), Box::new(r)),
    <l: Item> AND <r: Enclosed> => Item::And(Box::new(l), Box::new(r)),
    <l: Item> OR <r: Enclosed> => Item::Or(Box::new(l), Box::new(r)),
}

// An enclosed expression is a parenthesized sub-expression or a negated
// sub-expression.
Enclosed: Item = {
    NOT <Enclosed> => Item::Not(Box::new(<>)),
    BOpen <Item> BClose => <>,
}

// A maybe negated filter can either be a filter expression or a negated
// filter expression
MaybeNegatedFilter: Item = {
    Filter => Item::Filter(<>),
    NOT <Filter> => Item::Not(Box::new(Item::Filter(<>))),
}


LHS: Path = {
    Path => <>
}

RHS: RHSValue = {
    ValueLit => RHSValue::Literal(<>),
    Path => RHSValue::Lookup(<>),
    RHSList => RHSValue::List(<>)
}


RHSList: Vec<RHSValue> = {
    "[" <RHSListItems> "]" => <>
}

RHSListItems: Vec<RHSValue> = {
    <list:RHSListItems> COMMA <item:RHSValue> => {
        let mut list: Vec<RHSValue> = list;
        list.push(item);
        list
    },
    RHSValue => vec![<>]
}


// A filter expression is one of: An IPV4 address An list reference A regular
// expression A wildcard ( glob-like ) expression A term A number Or a negated
// sub-filter
Filter: Filter = {
    <lhs:LHS> => Filter{
        lhs, rhs: Cmp::Exists
    },
    // `_` will always match, we test if the top level object exists, wich is always true
    USCORE => Filter{ rhs: Cmp::Exists, lhs: Path::DataPath(Vec::new()) },
    <lhs:LHS> EQ <rhs:RHS> => Filter{
        lhs, rhs: Cmp::Eq(rhs)
    },
    <lhs:LHS> GT <rhs:RHS> => Filter{
        lhs, rhs: Cmp::Gt(rhs)
    },
    <lhs:LHS> LT <rhs:RHS> => Filter{
        lhs, rhs: Cmp::Lt(rhs)
    },
    <lhs:LHS> GTE <rhs:RHS> => Filter{
        lhs, rhs: Cmp::Gte(rhs)
    },
    <lhs:LHS> LTE <rhs:RHS> => Filter{
        lhs, rhs: Cmp::Lte(rhs)
    },
    <lhs:LHS> CON <rhs:CIDRLit> => Filter{
        lhs, rhs: Cmp::CIDRMatch(rhs)
    },
    <lhs:LHS> CON <rhs:GlobLit> => Filter{
        lhs, rhs: Cmp::Glob(rhs)
    },
    <lhs:LHS> CON <rhs:RegexLit> => Filter{
        lhs, rhs: Cmp::Regex(rhs)
    },
    // The contains filter test if a string
    // is contained in a substring as well as
    // if a value is in a event-list
    //
    // TODO: This overlaps with string contains
    // we should fix this
    <lhs:LHS> CON <rhs:RHS> => Filter{
        lhs, rhs: Cmp::Contains(rhs)
    },
}


// Action Blocks are used to execute actions
// based on matched filters
Actions: Vec<Action> = {
    <actions: Actions> ";" <action: Action> => {
        let mut actions: Vec<Action> = actions;
        actions.push(action);
        actions
    },
    <Action> => vec![<>],
}

Action: Action = {
    <lhs:LHS> STO <rhs:RHS> => Action::Set{
        lhs, rhs
    },
    RETURN => Action::Return,
}

RHSValue: RHSValue = {
    ValueLit => RHSValue::Literal(<>),
    Path => RHSValue::Lookup(<>),
}

// A path used to access nested json values
// it uses a dot notation.
// TODO: Add array index support?
DataPath: Vec<Id> = {
    <path:DataPath> DOT <key:Id> => {
      let mut path = path;
        path.push(key);
        path
    },
    Id => vec![<>],
}

Path: Path = {
    DataPath => Path::DataPath(<>),
    DOLLAR <Id> => Path::Var(<>)
}


// LITERALS

// A CIDR or  IP, where a plain IP (i.e. 10.5.8.20) is treated as the CIDR 10.5.8.20/32
CIDRLit: CIDR = {
    IP =>
    {
        let re = regex::Regex::new(r"(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,2})/?(\d{1,2})?").unwrap();
        let caps = re.captures(<>).unwrap();
        let a = u8::from_str(caps.get(1).map_or("", |m| m.as_str())).unwrap();
        let b = u8::from_str(caps.get(2).map_or("", |m| m.as_str())).unwrap();
        let c = u8::from_str(caps.get(3).map_or("", |m| m.as_str())).unwrap();
        let d = u8::from_str(caps.get(4).map_or("", |m| m.as_str())).unwrap();
        let e = u8::from_str(caps.get(5).map_or("32", |m| m.as_str())).unwrap();
        CIDR::new(a, b, c, d, e)
    },
}


ValueLit: Value = {
    DblLit => <>,
    IntLit => <>,
    StrLit => <>,
    BoolLit => <>,
}

BoolLit: Value = {
    TRUE => Value::Bool(true),
    FALSE => Value::Bool(false),
}

// A string literal
StrLit: Value = {
    STRING => Value::String(<>.trim_matches('"').to_string())
}

Id: Id = {
    IDTOKEN => Id::new(<>),
}
// A double literal
DblLit: Value = DOUBLE => json!(f64::from_str(<>).unwrap());

// An integer literal
IntLit: Value = LONG => json!(i64::from_str(<>).unwrap());

// A regular expression
RegexLit: Regex = { <Regexstr> => RegexBuilder::new().jit(true).jit_if_available(true).build(&<>.trim_matches('/').to_string()).unwrap()};

// A glob
GlobLit: Pattern = { <Globstr> => Pattern::new(&<>.trim_matches('g').trim_matches('"').to_string()).unwrap()};

// Helpers
Regexstr: String = REGEX => <>.to_string();
Globstr: String =  GLOB => <>.to_string() ;

match {
    r"((?i)and)|(\&\&)" => AND,
    r"((?i)or)|(\|\|)" => OR,
    r"((?i)not)|(!)" => NOT,
    "import" => IMPORT,
    "true" => TRUE,
    "false" => FALSE,
    "export" => EXPORT,
    "return" => RETURN,
} else {
    ":" => CON,
    "=" => EQ,
    ">" => GT,
    "<" => LT,
    ">=" => GTE,
    "<=" => LTE,
    "." => DOT,
    "_" => USCORE,
    "$" => DOLLAR,
    ":=" => STO,
    "," => COMMA,
    "{" => CBOpen,
    "}" => CBClose,
    "(" => BOpen,
    ")" => BClose,
} else {
    r"[+-]?[0-9]+" => LONG,
    r"[+-]?[0-9]+\.[0-9]+" => DOUBLE,
    r"(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/?(\d{1,2})?" => IP,
    r#""([\\].|[^"])*""# => STRING,
    r"[a-zA-Z][a-zA-Z0-9_-]*|'[a-zA-Z][a-zA-Z0-9_-]*'" => IDTOKEN,
} else {
    r"#[^\n]*" => SLC,
    r"[/](([\\][/])|[^/])+[/]" => REGEX,
    r#"[g]["](([\\]["])|[^"])+["]"# => GLOB,
     _
}
