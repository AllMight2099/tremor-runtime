// Copyright 2018, Wayfair GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use regex;
use std::str::FromStr;
use super::{Item, Stmt, Cmp, Filter, CIDR, Action, MimirValue};
use pcre2::bytes::{RegexBuilder, Regex};
use glob::Pattern;

grammar;

pub Stmt: Stmt = {
    Item => Stmt{item: <>, actions: Vec::new()},
    <item:Item> CBOpen <actions: Actions> ";" CBClose => Stmt{item, actions},
}

// Filter related

// An item can be a filter expression, a parenthesized expression, or a
// predicate expression.
Item: Item = {
    MaybeNegatedFilter => <>,
    Enclosed => <>,
    <l: Item> AND <r: MaybeNegatedFilter> => Item::And(Box::new(l), Box::new(r)),
    <l: Item> OR <r: MaybeNegatedFilter> => Item::Or(Box::new(l), Box::new(r)),
    <l: Item> AND <r: Enclosed> => Item::And(Box::new(l), Box::new(r)),
    <l: Item> OR <r: Enclosed> => Item::Or(Box::new(l), Box::new(r)),
}

// An enclosed expression is a parenthesized sub-expression or a negated
// sub-expression.
Enclosed: Item = {
    NOT <Enclosed> => Item::Not(Box::new(<>)),
    BOpen <Item> BClose => <>,
}


// A maybe negated filter can either be a filter expression or a negated
// filter expression
MaybeNegatedFilter: Item = {
    Filter => Item::Filter(<>),
    NOT <Filter> => Item::Not(Box::new(Item::Filter(<>))),
}

// A filter expression is one of: An IPV4 address An list reference A regular
// expression A wildcard ( glob-like ) expression A term A number Or a negated
// sub-filter
Filter: Filter = {
    <path:Path> => Filter{
        cmp: Cmp::Exists, path
    },
    ListContainFilter => <>,
    StrFilter => <>,
    IntFilter => <>,
    DblFilter => <>,
    CIDRFilter => <>,
    ListIncludesFilter => <>
}

// An CIDR filter filters based on CIDR subnet matche
CIDRFilter: Filter = {
    <path:Path> CON <value:CIDRLit> => Filter{
        cmp: Cmp::CIDRMatch(value), path
    },

}

// String filters allow for various types of filtering
// of strings.
StrFilter: Filter = {
    <path:Path> EQ <value:StrLit> => Filter{
        cmp: Cmp::Eq(value), path
    },
    <path:Path> GT <value:StrLit> => Filter{
        cmp: Cmp::Gt(value), path
    },
    <path:Path> CON <regex:RegexLit> => Filter{
        cmp: Cmp::Regex(regex), path
    },
    <path:Path> CON <glob:GlobLit> => Filter{
        cmp: Cmp::Glob(glob), path
    },
}

// Integer filters allow for various types of filtering
// of integers.
IntFilter: Filter = {
    <path:Path> EQ <value:IntLit> => Filter{
        cmp: Cmp::Eq(value), path
    },
    <path:Path> GT <value:IntLit> => Filter{
        cmp: Cmp::Gt(value), path
    },
    <path:Path> LT <value:IntLit> => Filter{
        cmp: Cmp::Lt(value), path
    },
    <path:Path> GTE <value:IntLit> => Filter{
        cmp: Cmp::Gte(value), path
    },
    <path:Path> LTE <value:IntLit> => Filter{
        cmp: Cmp::Lte(value), path
    },
}

// The contains filter test if a string
// is contained in a substring as well as
// if a value is in a event-list
//
// TODO: This overlaps with string contains
// we should fix this?th
ListContainFilter: Filter = {
    <path:Path> CON <value:DblLit> => Filter{
        cmp: Cmp::Contains(value), path
    },
    <path:Path> CON <value:IntLit> => Filter{
        cmp: Cmp::Contains(value), path
    },
    <path:Path> CON <value:StrLit> => Filter{
        cmp: Cmp::Contains(value), path
    },
}

// The includes filter tests if a event value
// is included in the given list literal.
ListIncludesFilter: Filter = {
    <path:Path> CON <value:ListLit> => Filter{
        cmp: Cmp::IsInList(value), path
    },
}

/// Various filters comparing double values.
DblFilter: Filter = {
    <path:Path> EQ <value:DblLit> => Filter{
        cmp: Cmp::Eq(value), path
    },
    <path:Path> GT <value:DblLit> => Filter{
        cmp: Cmp::Gt(value), path
    },
    <path:Path> LT <value:DblLit> => Filter{
        cmp: Cmp::Lt(value), path
    },
    <path:Path> GTE <value:DblLit> => Filter{
        cmp: Cmp::Gte(value), path
    },
    <path:Path> LTE <value:DblLit> => Filter{
        cmp: Cmp::Lte(value), path
    },
}

// Action Blocks are used to execute actions
// based on matched filters
Actions: Vec<Action> = {
    <actions: Actions> ";" <action: Action> => {
        let mut actions: Vec<Action> = actions;
        actions.push(action);
        actions
    },
    <Action> => vec![<>],
}

Action: Action = {
    <path:Path> STO <value:MimirValueLit> => Action::Set{
        path, value
    }
}

// A path used to access nested json values
// it uses a dot notation.
// TODO: Add array index support?
Path: Vec<String> = {
    <path:Path> DOT <key:PathKey> => {
      let mut path: Vec<String> = path;
        path.push(key);
        path
    },
    PathKey => vec![<>],
}

PathKey: String = { Str => <>.to_string() }

// LITERALS

// A CIDR or  IP, where a plain IP (i.e. 10.5.8.20) is treated as the CIDR 10.5.8.20/32
CIDRLit: CIDR = {
    IP =>
    {
        let re = regex::Regex::new(r"(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,2})/?(\d{1,2})?").unwrap();
        let caps = re.captures(<>).unwrap();
        let a = u8::from_str(caps.get(1).map_or("", |m| m.as_str())).unwrap();
        let b = u8::from_str(caps.get(2).map_or("", |m| m.as_str())).unwrap();
        let c = u8::from_str(caps.get(3).map_or("", |m| m.as_str())).unwrap();
        let d = u8::from_str(caps.get(4).map_or("", |m| m.as_str())).unwrap();
        let e = u8::from_str(caps.get(5).map_or("32", |m| m.as_str())).unwrap();
        CIDR::new(a, b, c, d, e)
    },
}

// A list literal [ lsit-item, list-item, ... ]
// that can contain mixed values
ListLit: Vec<MimirValue> = {
    "[" <ListLitItems> "]" => <>
}

ListLitItems: Vec<MimirValue> = {
    <list:ListLitItems> COMMA <item:MimirValueLit> => {
        let mut list: Vec<MimirValue> = list;
        list.push(item);
        list
    },
    MimirValueLit => vec![<>]
}

MimirValueLit: MimirValue = {
    DblLit => <>,
    IntLit => <>,
    StrLit => <>,
}

// A string literal
StrLit: MimirValue = {
    "\"" <Plainstr> "\"" => <>
}

// A double literal
DblLit: MimirValue = DOUBLE => json!(f64::from_str(<>).unwrap());

// An integer literal
IntLit: MimirValue = LONG => json!(i64::from_str(<>).unwrap());

// A regular expression
RegexLit: Regex = { <Regexstr> => RegexBuilder::new().jit(true).jit_if_available(true).build(&<>.trim_matches('/').to_string()).unwrap()};

// A glob
GlobLit: Pattern = { <Globstr> => Pattern::new(&<>.trim_matches('g').trim_matches('"').to_string()).unwrap()};

// Helpers
Regexstr: String = REGEX => <>.to_string();
Globstr: String =  GLOB => <>.to_string() ;
Plainstr: MimirValue = TEXT => json!(<>.to_string());
Str: String = TEXT => <>.to_string();

match {
    r"[+-]?[0-9]+" => LONG,
    r"[+-]?[0-9]+\.[0-9]+" => DOUBLE,
    r"((?i)and)|(\&\&)" => AND,
    r"((?i)or)|(\|\|)" => OR,
    r"((?i)not)|(!)" => NOT,
    r"(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/?(\d{1,2})?" => IP,
    ":" => CON,
    "=" => EQ,
    ">" => GT,
    "<" => LT,
    ">=" => GTE,
    "<=" => LTE,
    "." => DOT,
    ":=" => STO,
    "," => COMMA,
    "{" => CBOpen,
    "}" => CBClose,
    "(" => BOpen,
    ")" => BClose,
} else {
    r"[a-zA-Z0-9_]+" => TEXT,
    r"[/](([\\][/])|[^/])+[/]" => REGEX,
    r####"[g]["](([\\]["])|[^"])+["]"#### => GLOB,
     _
}
